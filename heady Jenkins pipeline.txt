    pipeline{
        environment{
            branch="chore/setup-ci"
            bitbucketCreds="ci-heady.io-bitbucketid"
            awsCreds="ams-dev-ci"
            credentials="bot-user-oauth-token-ams-migration-command"
            secretName="/devplatform/dev/env"
            // envFile=credentials("/mwh/dev/env")
            project="bb_nginx-dev"
            //projects=sh("yq e '.services[].container_name' < docker-compose.yml |xargs|tr -s " " ","")
            containerName="nginx-proxy"
            docker_network="devplatform-default"
            port="80"
            buildEnv="dev"
            repoUrl="git@bitbucket.org:headyio/ams-cienega.git"
            ecrRegistry ="https://312885460084.dkr.ecr.us-east-1.amazonaws.com/"
            ecr="312885460084.dkr.ecr.us-east-1.amazonaws.com"
            slackChannel="#ams-jenkins-builds"
            slackToken="XXXXXXXXXX"
            random="${Math.round(Math.random() * 100000) % 15  }"
            //commitID = getVersion()
            logFile="devplatform_nginx-dev.log"
        }
        agent any
         options {
            lock resource: "cienega"
        }
        stages{
            stage("git clone"){
                steps{
                    echo "Pulling creds & Cloning git repo"
                    //writeFile file: '.env', text: "$envFile"
                    git branch: "$branch", credentialsId: "$bitbucketCreds", url: "$repoUrl"
                    echo "Updating nginx conf file according to $buildEnv environment"
                    sh "cp infrastructure/docker/main/nginx/default.conf infrastructure/docker/main/nginx/default.conforg"
                    sh "sed -e s#\\\$ENV_NAME#\$buildEnv#g infrastructure/docker/main/nginx/default.conforg > infrastructure/docker/main/nginx/default.conf"
                    //getEnvCreds()
                    
                }
                post{
                    always{
                        echo "========always========"
                    }
                    success{
                        echo "========git clone executed successfully========"
                    }
                    failure{
                        echo "========git clone execution failed========"
                    }
                }
            }
            stage("get version"){
                steps{
                    script{
                        env.commitID = getVersion()
                        print(env.commitID)
                    }
                }
                post{
                    always{
                        echo "====++++always++++===="
                    }
                    success{
                        echo "====++++Commit ID added successfully++++===="
                    }
                    failure{
                        echo "====++++Commit ID addition failed++++===="
                    }
            
                }
                
            }
            stage("Build image"){
                steps{
                    script {
                        stage('Deleting Containers') {
                            sh 'sleep 10'
                            sh 'docker ps -qaf "name=${containerName}"  | xargs --no-run-if-empty docker stop'
                            sh 'sleep 5'
                            sh 'docker ps -qaf "name=${containerName}"  | xargs --no-run-if-empty docker rm'
                        }
    
                        stage('Deleting Images') {
                            sh 'docker rmi $(docker images -q -f reference=${project}-${buildEnv}*) --force || true'
                        }
        
                        stage('deleting Volumes') {
                            sh 'docker volume prune --force'
                        }
                    }
                    echo "====++++Building image++++===="
                    step([$class: 'DockerComposeBuilder', dockerComposeFile: 'docker-compose-server.yml', option: [$class: 'StartService', scale: 0, service: "$containerName"], useCustomDockerComposeFile: true])
                    step([$class: 'DockerComposeBuilder', dockerComposeFile: 'docker-compose-server.yml', option: [$class: 'StopService', service: "$containerName"], useCustomDockerComposeFile: true])
                    step([$class: 'DockerBuilderControl', option: [$class: 'DockerBuilderControlOptionStopAll', remove: true]])
                }
                post{
                    always{
                        echo "====++++always++++===="
                        //step([$class: 'DockerBuilderControl', option: [$class: 'DockerBuilderControlOptionStopAll', remove: true]])
                    }
                    success{
                        echo "====++++Build image executed successfully++++===="
                    }
                    failure{
                        echo "====++++Build image execution failed++++===="
                    }
            
                }
            }
            stage("Push image to ecr"){
                steps{
                    echo "====++++executing Push image to ecr++++===="
                    pushToRegistry()
                     //script {
                        
                    //}
                }
                post{
                    always{
                        echo "====++++always++++===="
                    }
                    success{
                        echo "====++++Push image to ecr executed successfully++++===="
                    }
                    failure{
                        echo "====++++Push image to ecr execution failed++++===="
                    }
            
                }
            }
            stage("ssh to deployment server and delete old containers and images"){
                steps{
                    echo "====++++executing ssh to deployment server++++===="
                    //script {
                    deleteAllContainersImages()  
                    //}
                }
                post{
                    always{
                        echo "====++++always++++===="
                    }
                    success{
                        echo "====++++ssh to deployment server executed successfully++++===="
                    }
                    failure{
                        echo "====++++ssh to deployment server execution failed++++===="
                    }
            
                }
            }
            stage("Pull image from ecr"){
                steps{
                    echo "====++++executing Pull image from ecr++++====:Skipped,Shifted to Kubernetes"
                    pullEcrImage()  
                    }
                post{
                    always{
                        echo "====++++always++++===="
                    }
                    success{
                        echo "====++++Pull image from ecr executed successfully++++===="
                    }
                    failure{
                        echo "====++++Pull image from ecr execution failed++++===="
                    }
            
                }
            }
            stage("Run docker image & deploy on kubernetes cluster:Skipped,Shifted to kubernetes"){
                steps{
                    echo "====++++executing docker image++++===="
                    startContainer()
                    //build 'wcm-dev-k8'
                    }
                post{
                    always{
                        echo "====++++always++++===="
                    }
                    success{
                        echo "====++++Run docker image executed successfully++++===="
                    }
                    failure{
                        echo "====++++Run docker image execution failed++++===="
                    }
            
                }
            }
        }
        post{
            always{
                echo "========always========"
            }
            success{
                echo "========pipeline executed successfully ========"
                slackSend channel: "$slackChannel", message: "${env.JOB_NAME} ${env.BUILD_NUMBER} Success (Commitid: ${env.commitID}, Branch: ${env.branch}) ", teamDomain: 'headyio', token:'XXXXXXX', tokenCredentialId: "$slackToken"    
            }
            failure{
                echo "========pipeline execution failed========"
                //slackSend channel: "$slackChannel", message: "${env.JOB_NAME} ${env.BUILD_NUMBER} Failure", teamDomain: 'headyio', token:'XXXXXX', tokenCredentialId: "$slackToken"
                //sendLog()
            }
         }
    }
    options:
      docker: true
    
    def deleteAllContainersImages(){
        sshPublisher(publishers: [sshPublisherDesc(configName: "${project}-${buildEnv}", transfers: [sshTransfer(cleanRemote: false, excludes: '', execCommand: "docker ps -qa --filter  name=${project}-${buildEnv} | xargs --no-run-if-empty docker stop && docker ps -qa --filter  name=${project}-${buildEnv} | xargs --no-run-if-empty docker rm", execTimeout: 120000, flatten: false, makeEmptyDirs: false, noDefaultExcludes: false, patternSeparator: '[, ]+', remoteDirectory: '', remoteDirectorySDF: false, removePrefix: '', sourceFiles: '')], usePromotionTimestamp: false, useWorkspaceInPromotion: false, verbose: true)])
        sshPublisher(publishers: [sshPublisherDesc(configName: "${project}-${buildEnv}", transfers: [sshTransfer(cleanRemote: false, excludes: '', execCommand: "docker rmi \$(docker images -q -f reference=*/${project}-${buildEnv}*) --force || true", execTimeout: 120000, flatten: false, makeEmptyDirs: false, noDefaultExcludes: false, patternSeparator: '[, ]+', remoteDirectory: '', remoteDirectorySDF: false, removePrefix: '', sourceFiles: '')], usePromotionTimestamp: false, useWorkspaceInPromotion: false, verbose: true)])
    }
    def pullEcrImage(){
        sshPublisher(publishers: [sshPublisherDesc(configName: "${project}-${buildEnv}", transfers: [sshTransfer(cleanRemote: false, excludes: '', execCommand: "aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin ${ecr}", execTimeout: 120000, flatten: false, makeEmptyDirs: false, noDefaultExcludes: false, patternSeparator: '[, ]+', remoteDirectory: '', remoteDirectorySDF: false, removePrefix: '', sourceFiles: '')], usePromotionTimestamp: false, useWorkspaceInPromotion: false, verbose: true)])
        sshPublisher(publishers: [sshPublisherDesc(configName: "${project}-${buildEnv}", transfers: [sshTransfer(cleanRemote: false, excludes: '', execCommand: "docker pull ${ecr}/${project}-${buildEnv}_${containerName}:latest", execTimeout: 120000, flatten: false, makeEmptyDirs: false, noDefaultExcludes: false, patternSeparator: '[, ]+', remoteDirectory: '', remoteDirectorySDF: false, removePrefix: '', sourceFiles: '')], usePromotionTimestamp: false, useWorkspaceInPromotion: false, verbose: true)])
    }
    def startContainer(){
        sshPublisher(publishers: [sshPublisherDesc(configName: "${project}-${buildEnv}", transfers: [sshTransfer(cleanRemote: false, excludes: '', execCommand: "docker network create ${docker_network} || true", execTimeout: 120000, flatten: false, makeEmptyDirs: false, noDefaultExcludes: false, patternSeparator: '[, ]+', remoteDirectory: '', remoteDirectorySDF: false, removePrefix: '', sourceFiles: '')], usePromotionTimestamp: false, useWorkspaceInPromotion: false, verbose: true)])
        sshPublisher(publishers: [sshPublisherDesc(configName: "${project}-${buildEnv}", transfers: [sshTransfer(cleanRemote: false, excludes: '', execCommand: "docker run -d -p ${port}:${port} --network ${docker_network} --name ${project}-${buildEnv} ${ecr}/${project}-${buildEnv}_${containerName}:latest", execTimeout: 120000, flatten: false, makeEmptyDirs: false, noDefaultExcludes: false, patternSeparator: '[, ]+', remoteDirectory: '', remoteDirectorySDF: false, removePrefix: '', sourceFiles: '')], usePromotionTimestamp: false, useWorkspaceInPromotion: false, verbose: true)])
        //sshPublisher(publishers: [sshPublisherDesc(configName: "${project}-${buildEnv}", transfers: [sshTransfer(cleanRemote: false, excludes: '', execCommand: "docker exec ${project}-${buildEnv} npm run migrate up", execTimeout: 120000, flatten: false, makeEmptyDirs: false, noDefaultExcludes: false, patternSeparator: '[, ]+', remoteDirectory: '', remoteDirectorySDF: false, removePrefix: '', sourceFiles: '')], usePromotionTimestamp: false, useWorkspaceInPromotion: false, verbose: false)])
    }
    def pushToRegistry(){
        docker.withRegistry("${ecrRegistry}","ecr:us-east-1:${awsCreds}") {
        docker.image("${project}-${buildEnv}_${containerName}").push('latest')
                        }
    }
    def getVersion(){
          def commitHash = sh returnStdout: true, script: 'git rev-parse --short HEAD'
          return commitHash
    }
    def getGitBranchName() {
        def branchName = sh(returnStdout: true, script: 'git rev-parse --abbrev-ref HEAD').trim()
        return branchName
    }
    def getEnvCreds() {
        withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', accessKeyVariable: 'AWS_ACCESS_KEY_ID', credentialsId: "$awsCreds", secretKeyVariable: 'AWS_SECRET_ACCESS_KEY']]) {
                        // some block
                        sh "./infrastructure/get-creds.py -s $secretName"
        }
    }
    def sendLog(){
        writeFile encoding: "UTF-8", file: 'jenkinsjob.log', text: "${currentBuild.rawBuild.getLog()}"
          sh 'cat jenkinsjob.log |egrep -i  "error|failed" -B10 -A10 -m1> $logFile'
          slackUploadFile channel: "$slackChannel", credentialId: "$credentials", filePath: "$logFile", initialComment: "$logFile"
    }